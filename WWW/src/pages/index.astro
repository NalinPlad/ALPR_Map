---
import Layout from '../layouts/Layout.astro';
---

<Layout>
	<div class="container">
		<div class="display">
			<div id="map"></div>
			<div id="info" class="flex"></div>
		</div>
		<div class="controls">
			<b id="t_label">Time</b>
			<input type="range" id="t_slider"/>
		</div>
	</div>

	<style>
		.container {
			height: 100vh;
			width: 100vw;
			max-width: 100%;
			max-height: 100%;

			display: flex;
			flex-direction: column
		}

		#t_slider {
			width: 75%;
		}

		.display {
			height: 85%;
			width: 100%;

			display: flex;
			flex-direction: row;
			/* padding: 5px; */

			/* overflow-y: scroll; */

			color: #fff;
		}

		.controls {
			width: 100%;
			height: 15%;
		
			background-color: rgb(34, 34, 34);
			border-top: 5px rgb(255, 255, 255) solid;

			/* padding: ; */

			display: flex;
			flex-direction: column;

			align-items: center;
			justify-content: center;

			color: white;

		}

		#map {
			width: 75%;
			height: 100%;
		}

		#info {
			background-color: rgb(34, 34, 34);
			border-left: 5px rgb(255, 255, 255) solid;
			width: 25%;
			height: 100%;

			padding: 5px;

			overflow-y: scroll;
		}

		.leaflet-container {
			background: rgb(34, 34, 34);
		}

		.search {
			color: white;
			background-color: red;
		}

	</style>

	<script>
		import { sequence } from "astro:middleware";
		import { slide } from "astro:transitions";
		import  initSqlJs  from "sql.js"

		const sqlPromise = await initSqlJs({
			locateFile: file => `https://sql.js.org/dist/${file}`
		});

		const dataPromise = fetch("/audit_db").then(res => res.arrayBuffer());
		const [SQL, buf] = await Promise.all([sqlPromise, dataPromise])
		const db = new SQL.Database(new Uint8Array(buf));


		// console.log(departments[0].values)
		
		var map = L.map('map').setView([37.7668, -122.267], 10);

		var dept_pins = []

		L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.{ext}', {
			minZoom: 4,
			maxZoom: 20,
			attribution: '&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
			ext: 'png'
		}).addTo(map);

		// 0.dept_slug	1.flock_status	2.name	3.last_updated	4.camera_count	5.vehicles_30_days	6.searches_30_days	7.latitude	8.longitude	9.state_code	10.leaflet object	11.playing	12.line group
		const departments = db.exec("SELECT * FROM departments WHERE flock_status = 200 AND latitude IS NOT NULL AND longitude IS NOT NULL")[0].values;

		//
		// const connections = db.exec("SELECT * FROM connections")

		var conn_layer = L.layerGroup();

		departments.forEach(dept => {
			dept[10] = L.marker([dept[7],dept[8]])
			dept[10].bindPopup(`
				<h3>${dept[2]}</h3>
				${dept[4] ? `<p><b>${dept[4].toLocaleString()}</b> cameras</p>` : ""}
				${dept[5] ? `<p><b>${dept[5].toLocaleString()}</b> vehicles past 30 days</p>` : ""}
				${dept[6] ? `<p><b>${dept[6].toLocaleString()}</b> searches past 30 days</p>` : ""}
			`);

			// dept[12] = L.l

			dept[11] = false


			dept_pins.push(dept[10])

			// dept[10].on('click', _ => {
            let connections = db.exec("SELECT * FROM connections WHERE dept_a = \"" + dept[2] + "\" AND dept_b IS NOT NULL")[0]

            if(connections != undefined) {
                
                
                connections = connections.values
                
                
                const p1 = [dept[7],dept[8]]
                
                connections.forEach(connection => {
                    // console.log(connection)
                    let p2 = db.exec(`SELECT latitude, longitude FROM departments WHERE name = "${connection[2]}" AND latitude IS NOT NULL`)[0]
                    if(p2 != undefined){

                        p2 = p2.values[0]
                        conn_layer.addLayer(L.polyline([p1,p2],{
                            color: "white",
                            opacity: 0.1,
                            weight: 1
                        }))
                    }

                });
            }
				// console.log(connections)
			// })

			
			

		});

		var dept_layer = L.layerGroup(dept_pins);


		var overlayMaps = {
			"Departments": dept_layer,
			"Connections": conn_layer
		};

		var layerControl = L.control.layers(null, overlayMaps).addTo(map);

		departments[0][10].openPopup();

		const first_time = db.exec("SELECT time FROM searches ORDER BY time ASC LIMIT 1")[0].values[0][0]
		const last_time = db.exec("SELECT time FROM searches ORDER BY time DESC LIMIT 1")[0].values[0][0]

		const searches = db.exec("SELECT * from searches ORDER BY time ASC")[0].values;

		const infobox = document.querySelector("#info")
		const slider = document.querySelector("#t_slider")
		const label = document.querySelector("#t_label")

		slider.min = first_time
		slider.max = last_time
		slider.step = 1
		

		slider.value = first_time
		label.innerText = Date(first_time)

		let c_time = first_time

		// 0.search_dept	1.search_id	2.user_id	3.time	4.camera_count	5.reason
		function draw_searches(time){
			infobox.innerHTML = ""
			console.log(time)
			const d = new Date(time)
			label.innerText = d.toLocaleString("en-US");
			searches.forEach(search => {
				if(search[3] <= time && search[3] >= time - 1*60*60*1000) {
					const dp = departments.filter(d => d[0] == search[0])[0]
					if(Math.abs(search[3] - time) < 10000 && dp[11] == false){
						// dp[10].setOpacity(1)
						dp[11] = true
						setTimeout(_ => {
							// dp[10].setOpacity(0.01)
							dp[11] = false
						}, 500)
					}
					// console.log(search)
					infobox.innerHTML = `<div class="search">${dp[2]}<br/>${search[5]}\n<hr/>\n</div>` + infobox.innerHTML
				} else {
					// dp[10].setOpacity(0)
				}
			})
		}

		slider.addEventListener("input", _ => {
			c_time = parseInt(slider.value)
			// console.log(c_time)
			draw_searches(c_time)
		})

		draw_searches(c_time)

		// setInterval(_ => {
		// 	c_time += 3000
		// 	draw_searches(c_time)
		// }, 200)

		// new method: for each set timeout to do next one based on log of difference between times of this and next search
		
	</script>
</Layout>